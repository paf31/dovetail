-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A PureScript interpreter with a Haskell FFI.
--   
--   Dovetail is a general-purpose PureScript corefn interpreter with an
--   FFI to Haskell. Please see the README on GitHub at
--   <a>https://github.com/paf31/dovetail#readme</a>, or check out the
--   examples directory, to learn how to use the library.
@package dovetail
@version 0.1.1.0

module Dovetail.Build
data BuildError
UnableToParse :: NonEmpty ParserError -> BuildError
UnableToCompile :: MultipleErrors -> BuildError
InternalError :: BuildError
renderBuildError :: BuildError -> String

-- | Parse and build a single PureScript module, returning the compiled
--   CoreFn module.
buildSingleModule :: [ExternsFile] -> Text -> Either BuildError (Module Ann, ExternsFile)

-- | Parse and build a single PureScript expression, returning the compiled
--   CoreFn module. The expression will be used to create a placeholder
--   module with the name <tt>Main</tt>, and a single expression named
--   <tt>main</tt>, with the specified content.
buildSingleExpression :: Maybe ModuleName -> [ExternsFile] -> Text -> Either BuildError (Expr Ann, SourceType)
buildSingleExpressionWith :: (Expr -> Expr) -> Maybe ModuleName -> [ExternsFile] -> Text -> Either BuildError (Expr Ann, SourceType)
buildSingleExpressionFromAST :: Maybe ModuleName -> [ExternsFile] -> Expr -> Either BuildError (Expr Ann, SourceType)

-- | Compile a single <a>Module</a> into a CoreFn module.
--   
--   This function is based on the <a>rebuildModule</a> function.
--   
--   It is reproduced and modified here in order to make it simpler to
--   build a single module without all of the additional capabilities and
--   complexity of the upstream API.
buildCoreFnOnly :: [ExternsFile] -> Module -> Either MultipleErrors ((Module Ann, ExternsFile), MultipleErrors)
instance GHC.Show.Show Dovetail.Build.BuildError

module Dovetail.FFI.Internal
forAll :: (SourceType -> SourceType) -> SourceType
array :: SourceType -> SourceType
function :: SourceType -> SourceType -> SourceType

module Dovetail.Types

-- | The representation of values used by the interpreter - essentially,
--   the semantic domain for a simple untyped lambda calculus with records
--   and ADTs.
--   
--   Any additional side effects which might occur in FFI calls to Haskell
--   code are tracked by a monad in the type argument.
data Value m

-- | Records are represented as hashmaps from their field names to values
Object :: HashMap Text (Value m) -> Value m
Array :: Vector (Value m) -> Value m
String :: Text -> Value m
Char :: Char -> Value m
Number :: Double -> Value m
Int :: Integer -> Value m
Bool :: Bool -> Value m

-- | Closures, represented in higher-order abstract syntax style.
Closure :: (Value m -> EvalT m (Value m)) -> Value m

-- | Fully-applied data constructors
Constructor :: ProperName 'ConstructorName -> [Value m] -> Value m

-- | Foreign data types
Foreign :: Dynamic -> Value m

-- | An environment, i.e. a mapping from names to evaluated values.
--   
--   An environment for a single built-in function can be constructed using
--   the <tt>builtIn</tt> function, and environments can be combined easily
--   using the <a>Monoid</a> instance for <a>Map</a>.
type Env m = Map (Qualified Ident) (Value m)

-- | The monad used by the interpreter, which supports error reporting for
--   errors which can occur during evaluation.
--   
--   The transformed monad is used to track any benign side effects that
--   might be exposed via the foreign function interface to PureScript
--   code.
newtype EvalT m a
EvalT :: ReaderT (EvaluationContext m) (ExceptT (EvaluationError m) m) a -> EvalT m a
[unEvalT] :: EvalT m a -> ReaderT (EvaluationContext m) (ExceptT (EvaluationError m) m) a
runEvalT :: EvalT m a -> m (Either (EvaluationError m) a)

-- | Non-transformer version of <a>EvalT</a>, useful in any settings where
--   the FFI does not use any side effects during evaluation.
type Eval = EvalT Identity
runEval :: Eval a -> Either (EvaluationError Identity) a

-- | An evaluation error containing the evaluation context at the point the
--   error was raised.
data EvaluationError m
EvaluationError :: EvaluationErrorType m -> EvaluationContext m -> EvaluationError m

-- | The type of error which was raised
[errorType] :: EvaluationError m -> EvaluationErrorType m

-- | The evaluation context at the point the error was raised.
[errorContext] :: EvaluationError m -> EvaluationContext m

-- | Errors which can occur during evaluation of PureScript code.
--   
--   PureScript is a typed language, and tries to prevent runtime errors.
--   However, in the context of this interpreter, we can receive data from
--   outside PureScript code, so it is possible that runtime errors can
--   occur if we are not careful. This is similar to how PureScript code
--   can fail at runtime due to errors in the FFI.
data EvaluationErrorType m

-- | A name was not found in the environment
UnknownIdent :: Qualified Ident -> EvaluationErrorType m

-- | The runtime representation of a value did not match the expected
--   representation
TypeMismatch :: Text -> Value m -> EvaluationErrorType m

-- | A record field did not exist in an <a>Object</a> value.
FieldNotFound :: Text -> Value m -> EvaluationErrorType m

-- | A pattern match failed to match its argument
InexhaustivePatternMatch :: [Value m] -> EvaluationErrorType m

-- | A pattern match received the wrong number of arguments
InvalidNumberOfArguments :: Int -> Int -> EvaluationErrorType m

-- | A pattern match occurred against a partially-applied data constructor
UnsaturatedConstructorApplication :: EvaluationErrorType m

-- | A PureScript string which contains lone surrogates which could not be
--   decoded. See <a>PSString</a>.
InvalidFieldName :: PSString -> EvaluationErrorType m

-- | An error occurred in a foreign function which is not tracked by any of
--   the other error types.
OtherError :: Text -> EvaluationErrorType m

-- | Render an <a>EvaluationError</a> as a human-readable string.
renderEvaluationError :: RenderValueOptions -> EvaluationError m -> String

-- | An evaluation context currently consists of an evaluation stack, which
--   is only used for debugging purposes.
--   
--   The context type is parameterized by a monad <tt>m</tt>, because stack
--   frames can contain environments, which can in turn contain
--   <a>Value</a>s, which may contain monadic closures. This can be useful
--   for inspecting values or resuming execution in the event of an error.
newtype EvaluationContext m
EvaluationContext :: [EvaluationStackFrame m] -> EvaluationContext m
[getEvaluationContext] :: EvaluationContext m -> [EvaluationStackFrame m]

-- | A single evaluation stack frame TODO: support frames for foreign
--   function calls
data EvaluationStackFrame m
EvaluationStackFrame :: Env m -> SourceSpan -> Expr Ann -> EvaluationStackFrame m

-- | The current environment in this stack frame
[frameEnv] :: EvaluationStackFrame m -> Env m

-- | The source span of the expression whose evaluation created this stack
--   frame.
[frameSource] :: EvaluationStackFrame m -> SourceSpan

-- | The expression whose evaluation created this stack frame.
[frameExpr] :: EvaluationStackFrame m -> Expr Ann

-- | Create a stack frame for the evaluation of an expression, and push it
--   onto the stack.
pushStackFrame :: Monad m => Env m -> Expr Ann -> EvalT m a -> EvalT m a

-- | Throw an error which captures the current execution context.
throwErrorWithContext :: (MonadError (EvaluationError x) m, MonadReader (EvaluationContext x) m) => EvaluationErrorType x -> m a

-- | Render a <a>Value</a> as human-readable text.
--   
--   As a general rule, apart from any closures, the rendered text should
--   evaluate to the value you started with (when <a>maximumDepth</a> is
--   not set).
renderValue :: RenderValueOptions -> Value m -> Text

-- | Options when rendering values as strings using <a>renderValue</a>.
data RenderValueOptions
RenderValueOptions :: Bool -> Maybe Int -> RenderValueOptions

-- | Should ANSI terminal color codes be emitted
[colorOutput] :: RenderValueOptions -> Bool

-- | The maximum depth of a subexpression to render, or <a>Nothing</a> to
--   render the entire <a>Value</a>.
[maximumDepth] :: RenderValueOptions -> Maybe Int

-- | Some sensible default rendering options for use on a terminal which
--   supports color.
defaultTerminalRenderValueOptions :: RenderValueOptions
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Dovetail.Types.EvalT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Dovetail.Types.EvaluationContext m) (Dovetail.Types.EvalT m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError (Dovetail.Types.EvaluationError m) (Dovetail.Types.EvalT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Dovetail.Types.EvalT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Dovetail.Types.EvalT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Dovetail.Types.EvalT m)
instance Control.Monad.Trans.Class.MonadTrans Dovetail.Types.EvalT

module Dovetail.FFI

-- | Describes a module which is implemented in Haskell, and made available
--   to PureScript code using its foreign function interface.
--   
--   Right now, this consists only of foreign value declarations, even
--   though the FFI supports other forms of interop.
--   
--   Values of this type can be constructed directly, but in many cases it
--   is simpler to use the <a>Dovetail.FFI.Builder</a> module instead.
--   
--   Values of this type can be consumed by the <a>toExterns</a> and
--   <a>toEnv</a> functions, and their results passed to the PureScript
--   APIs or the low-level functions in <a>Dovetail.Evaluate</a> and
--   <a>Dovetail.Build</a>, directly, but it is more likely that you will
--   use values of this type with the higher-level <a>ffi</a> function.
data FFI m
FFI :: ModuleName -> [ForeignImport m] -> FFI m

-- | The module name for the module being implemented in Haskell.
[ffi_moduleName] :: FFI m -> ModuleName

-- | A list of values implemented in Haskell in this module.
[ffi_values] :: FFI m -> [ForeignImport m]

-- | A single value implemented in a foreign Haskell module.
data ForeignImport m
ForeignImport :: Ident -> SourceType -> Value m -> ForeignImport m

-- | The name of this value in PureScript code
[fv_name] :: ForeignImport m -> Ident

-- | The PureScript type of this value
[fv_type] :: ForeignImport m -> SourceType

-- | The value itself
[fv_value] :: ForeignImport m -> Value m

-- | Convert a foreign module into an evaluation environment.
--   
--   For advanced use cases, the result may be used with the functions in
--   the <a>Dovetail.Evaluate</a> module.
toEnv :: FFI m -> Env m

-- | Convert a foreign module into a PureScript externs file, for use
--   during separate compilation.
--   
--   For advanced use cases, the result may be used with the functions in
--   the <a>Dovetail.Build</a> module.
toExterns :: FFI m -> ExternsFile

module Dovetail.Evaluate

-- | Evaluate each of the bindings in a compiled PureScript module, and
--   store the evaluated values in the environment, without evaluating any
--   main expression.
buildCoreFn :: MonadFix m => Env m -> Module Ann -> EvalT m (Env m)

-- | Create an environment from a Haskell value.
--   
--   It is recommended that a type annotation is given for the type of the
--   value being provided.
--   
--   For example:
--   
--   <pre>
--   builtIn (ModuleName <a>Main</a>) "greeting" ("Hello, World!" :: Text)
--   builtIn (ModuleName <a>Main</a>) "somePrimes" ([2, 3, 5, 7, 11] :: Vector Integer)
--   </pre>
--   
--   Functions can be provided as built-ins, but the <a>EvalT</a> monad
--   needs to be used to wrap any outputs (or values in positive position):
--   
--   <pre>
--   builtIn (ModuleName <a>Main</a>) "strip" ((pure . Text.strip) :: Text -&gt; EvalT m Text)
--   builtIn (ModuleName <a>Main</a>) "map" (traverse :: (Value -&gt; EvalT m Value) -&gt; Vector Value -&gt; EvalT m (Vector Value))
--   </pre>
--   
--   Polymorphic functions can also be provided as built-ins, but values
--   with polymoprhic types will need to be passed across the FFI boundary
--   with monomorphic types. The type <a>Value</a> can always be used to
--   represent values of unknown or polymorphic type, as in the
--   <tt>map</tt> example above.
builtIn :: ToValue m a => ModuleName -> Text -> a -> Env m

-- | Evaluate a PureScript CoreFn expression in the given environment.
--   
--   Note: it should not be necessary to call this function directly in
--   most circumstances. It is provided as a helper function, for some more
--   advanced use cases, such as setting up a custom environment.
eval :: forall m. MonadFix m => Env m -> Expr Ann -> EvalT m (Value m)

-- | Apply a value which represents an unevaluated closure to an argument.
apply :: MonadFix m => Value m -> Value m -> EvalT m (Value m)

-- | Values which can be communicated across the FFI boundary from Haskell
--   to PureScript.
--   
--   Instances should identify and document any valid representations as a
--   subset of the semantic domain <a>Value</a>. Such a subset can be
--   identified by an injective function <a>toValue</a>, and a partial
--   inverse, <a>fromValue</a>, defined on the image of <a>toValue</a>.
--   
--   Laws:
--   
--   <pre>
--   fromValue . toValue = pure
--   </pre>
class MonadFix m => ToValue m a

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: ToValue m a => a -> Value m

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: (ToValue m a, Generic a, ToObject m (Rep a)) => a -> Value m
fromValue :: ToValue m a => Value m -> EvalT m a
fromValue :: (ToValue m a, Generic a, ToObject m (Rep a)) => Value m -> EvalT m a

-- | <a>ToValue</a> should support functions with types such as
--   
--   <pre>
--   a -&gt; EvalT m b
--   a -&gt; b -&gt; EvalT m c
--   a -&gt; b -&gt; c -&gt; EvalT m d
--   (a -&gt; EvalT m b) -&gt; EvalT m c
--   (a -&gt; b -&gt; EvalT m c) -&gt; EvalT m d
--   </pre>
--   
--   Note that every type in a return position is wrapped in the
--   <a>EvalT</a> monad transformer. This is because evaluation in general
--   may result in errors. However, a naive translation would result in too
--   many applications of <a>EvalT</a>.
--   
--   Specifically, we do not want to require types such as these, in which
--   <a>EvalT</a> appears on the right hand side of every function arrow:
--   
--   <pre>
--   a -&gt; EvalT m b (b -&gt; EvalT m c)
--   a -&gt; EvalT m b (b -&gt; EvalT m (c -&gt; EvalT m d))
--   </pre>
--   
--   For this reason, the <a>ToValue</a> instance for functions delegates
--   to this type class for the type on the right hand side of the
--   function. It skips the application of <a>EvalT</a> for nested function
--   types.
class ToValueRHS m a
toValueRHS :: ToValueRHS m a => a -> EvalT m (Value m)
fromValueRHS :: ToValueRHS m a => EvalT m (Value m) -> a

-- | This type can be used to make custom Haskell types accessible to
--   PureScript code via the FFI's <tt>foreign import data</tt> feature.
newtype ForeignType a
ForeignType :: a -> ForeignType a
[getForeignType] :: ForeignType a -> a

-- | Options for customizing generic deriving of record instances
data ObjectOptions
ObjectOptions :: (Text -> Text) -> ObjectOptions

-- | Map a Haskell field name to a PureScript field name on the
--   corresponding record type.
[toPureScriptField] :: ObjectOptions -> Text -> Text

-- | <ul>
--   <li>Maps Haskell field names to PureScript field names,
--   unmodified.</li>
--   </ul>
defaultObjectOptions :: ObjectOptions

-- | Derived <a>toValue</a> function for Haskell record types which should
--   map to corresponding PureScript record types.
genericToValue :: (MonadFix m, Generic a, ToObject m (Rep a)) => ObjectOptions -> a -> Value m

-- | Derived <a>fromValue</a> function for Haskell record types which
--   should map to corresponding PureScript record types.
genericFromValue :: (MonadFix m, Generic a, ToObject m (Rep a)) => ObjectOptions -> Value m -> EvalT m a

-- | This class is used in the default instance for <a>ToValue</a>, via
--   generic deriving, in order to identify a Haskell record type (with a
--   single data constructor and named fields) with values in the semantic
--   domain corresponding to a PureScript record type with the same field
--   names.
class ToObject m f
toObject :: ToObject m f => ObjectOptions -> f x -> HashMap Text (Value m)
fromObject :: ToObject m f => ObjectOptions -> HashMap Text (Value m) -> EvalT m (f x)
evalPSString :: MonadFix m => PSString -> EvalT m Text
instance Control.Monad.Fix.MonadFix m => Dovetail.Evaluate.ToValue m (Dovetail.Types.Value m)
instance Control.Monad.Fix.MonadFix m => Dovetail.Evaluate.ToValue m GHC.Integer.Type.Integer
instance Control.Monad.Fix.MonadFix m => Dovetail.Evaluate.ToValue m GHC.Types.Double
instance Control.Monad.Fix.MonadFix m => Dovetail.Evaluate.ToValue m Data.Text.Internal.Text
instance Control.Monad.Fix.MonadFix m => Dovetail.Evaluate.ToValue m GHC.Types.Char
instance Control.Monad.Fix.MonadFix m => Dovetail.Evaluate.ToValue m GHC.Types.Bool
instance (Control.Monad.Fix.MonadFix m, Dovetail.Evaluate.ToValue m a, Dovetail.Evaluate.ToValueRHS m b) => Dovetail.Evaluate.ToValue m (a -> b)
instance Dovetail.Evaluate.ToValue m a => Dovetail.Evaluate.ToValue m (Data.Vector.Vector a)
instance (Control.Monad.Fix.MonadFix m, Data.Typeable.Internal.Typeable a) => Dovetail.Evaluate.ToValue m (Dovetail.Evaluate.ForeignType a)
instance (Control.Monad.Fix.MonadFix m, Dovetail.Evaluate.ToValue m a, Dovetail.Evaluate.ToValueRHS m b) => Dovetail.Evaluate.ToValueRHS m (a -> b)
instance (Dovetail.Evaluate.ToValue m a, n GHC.Types.~ m) => Dovetail.Evaluate.ToValueRHS m (Dovetail.Types.EvalT n a)
instance (GHC.TypeLits.KnownSymbol field, Dovetail.Evaluate.ToValue m a) => Dovetail.Evaluate.ToObject m (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) u s l) (GHC.Generics.K1 r a))
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). (GHC.Base.Functor m, Dovetail.Evaluate.ToObject m f) => Dovetail.Evaluate.ToObject m (GHC.Generics.M1 GHC.Generics.D t f)
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). (GHC.Base.Functor m, Dovetail.Evaluate.ToObject m f) => Dovetail.Evaluate.ToObject m (GHC.Generics.M1 GHC.Generics.C t f)
instance forall k (m :: * -> *) (f :: k -> *) (g :: k -> *). (Control.Monad.Fix.MonadFix m, Dovetail.Evaluate.ToObject m f, Dovetail.Evaluate.ToObject m g) => Dovetail.Evaluate.ToObject m (f GHC.Generics.:*: g)

module Dovetail.REPL

-- | Starts a minimal interactive debugger (REPL) session.
--   
--   It is more likely that you will want to use the <a>repl</a> function
--   to start a REPL session from within an <a>InterpretT</a> block.
defaultMain :: forall m. (MonadFix m, MonadIO m, MonadMask m) => Maybe ModuleName -> [ExternsFile] -> [Ident] -> Env m -> m ()


-- | This module provides a higher-level API on top of the
--   <a>Dovetail.FFI</a> module. It is not as expressive as the functions
--   in that module, but has the benefit that it is much harder to use this
--   module to construct an FFI which will result in runtime errors, since
--   it attempts to synthesize the types of the Haskell implementations
--   from the types of the declared PureScript foreign imports.
module Dovetail.FFI.Builder

-- | A monad for constructing <a>FFI</a> data structures.
--   
--   For example:
--   
--   <pre>
--   FFI.<a>evalFFIBuilder</a> (<a>ModuleName</a> "Example") do
--     FFI.<a>foreignImport</a> (P.Ident "example")
--       (a -&gt; a ~&gt; a)
--       pure
--   </pre>
data FFIBuilder m a

-- | Run a computation in the <a>FFIBuilder</a> monad, returning the result
--   of the computation alongside the constructed <a>FFI</a>.
runFFIBuilder :: ModuleName -> FFIBuilder m a -> (a, FFI m)

-- | Run a computation in the <a>FFIBuilder</a> monad, returning only the
--   constructed <a>FFI</a>.
evalFFIBuilder :: ModuleName -> FFIBuilder m a -> FFI m

-- | Define a value which will be implemented in Haskell.
--   
--   The first argument gives a name to the value on the PureScript side.
--   
--   The second argument is a function which describes its PureScript type.
--   See <a>ForAll</a> for an explanation of its purpose.
--   
--   The final argument is the Haskell implementation of the value.
--   
--   The type checker will ensure that the PureScript and Haskell types are
--   compatible.
foreignImport :: (MonadFix m, ToValue m a, ForAll m a ty) => Ident -> ty -> a -> FFIBuilder m ()
data FunctionType m l r

-- | The PureScript string type
string :: FunctionType m Text (EvalT m Text)

-- | The PureScript char type
char :: FunctionType m Char (EvalT m Char)

-- | The PureScript boolean type
boolean :: FunctionType m Bool (EvalT m Bool)

-- | The PureScript number type
number :: FunctionType m Double (EvalT m Double)

-- | The PureScript integer type
int :: FunctionType m Integer (EvalT m Integer)

-- | Construct a PureScript array type
array :: FunctionType m l r -> FunctionType m (Vector l) (EvalT m (Vector l))

-- | Construct a PureScript function type
(~>) :: FunctionType m al ar -> FunctionType m bl br -> FunctionType m (al -> br) (al -> br)
infixr 0 ~>

-- | This type class exists to facilitate the concise description of
--   PureScript type schemes using the <a>foreignImport</a> function. It is
--   best understood via its examples:
--   
--   <pre>
--   foreignImport (Ident "identity") a -&gt; a ~&gt; a
--     :: MonadFix m 
--     =&gt; (Value m -&gt; EvalT m (Value m)) 
--     -&gt; FFIBuilder m ()
--   
--   foreignImport (Ident "flip") a b c -&gt; (a ~&gt; b ~&gt; c) ~&gt; b ~&gt; a ~&gt; c
--     :: MonadFix m 
--     =&gt; ((Value m -&gt; Value m -&gt; EvalT m (Value m))
--     -&gt;   Value m -&gt; Value m -&gt; EvalT m (Value m))
--     -&gt; FFIBuilder m ()
--   </pre>
--   
--   These Haskell functions applications describe the PureScript type
--   schemes for the <tt>identity</tt> and <tt>flip</tt> functions
--   respectively.
--   
--   Notice that the result type of these applications indicates the
--   corresponding Haskell type which must be implemented in order to
--   satisfy the contract of the FFI. Note, these types have been are
--   inferred, which highlights why this type class is worth its seeming
--   complexity: the goal is to allow the user to express the PureScript
--   type, and have the compiler compute the Haskell type for us. This is
--   about as simple as things can get - we cannot simply specify the
--   Haskell implementation and infer the PureScript type, because there is
--   not a single best PureScript type for every given Haskell type.
class ForAll m r a | a -> m r
instance Control.Monad.Writer.Class.MonadWriter (Dovetail.FFI.Builder.ForeignImports m) (Dovetail.FFI.Builder.FFIBuilder m)
instance GHC.Base.Monad (Dovetail.FFI.Builder.FFIBuilder m)
instance GHC.Base.Applicative (Dovetail.FFI.Builder.FFIBuilder m)
instance GHC.Base.Functor (Dovetail.FFI.Builder.FFIBuilder m)
instance GHC.Base.Semigroup (Dovetail.FFI.Builder.ForeignImports m)
instance GHC.Base.Monoid (Dovetail.FFI.Builder.ForeignImports m)
instance Dovetail.FFI.Builder.ForAll m a (Dovetail.FFI.Builder.FunctionType m a r_)
instance (Dovetail.FFI.Builder.ForAll m r o, a GHC.Types.~ Dovetail.FFI.Builder.FunctionType m (Dovetail.Types.Value m) (Dovetail.Types.EvalT m (Dovetail.Types.Value m))) => Dovetail.FFI.Builder.ForAll m r (a -> o)


-- | A tiny standard library.
module Dovetail.Prelude
stdlib :: MonadFix m => [FFI m]
prelude :: MonadFix m => FFI m
preludeArray :: MonadFix m => FFI m
preludeString :: MonadFix m => FFI m
preludeChar :: MonadFix m => FFI m
preludeNumber :: MonadFix m => FFI m
preludeInt :: MonadFix m => FFI m
preludeBoolean :: MonadFix m => FFI m
preludeDebug :: MonadFix m => FFI m
eqOps :: (ToValue m a, ToValueRHS m (EvalT m a), Eq a) => FunctionType m a (EvalT m a) -> FFIBuilder m ()
numOps :: (ToValue m a, ToValueRHS m (EvalT m a), Num a) => FunctionType m a (EvalT m a) -> FFIBuilder m ()
ordOps :: (ToValue m a, ToValueRHS m (EvalT m a), Ord a) => FunctionType m a (EvalT m a) -> FFIBuilder m ()

module Dovetail

-- | A monad transformer for high-level tasks involving PureScript code,
--   including separate compilation. Its job is to keep track of available
--   modules, any foreign imports from Haskell code, and run PureScript
--   code.
--   
--   Note: do not confuse this monad transformer with <a>EvalT</a>, which
--   is only responsible for powering evaluation of PureScript expressions.
--   
--   The transformed monad is used to track any benign side effects that
--   might be exposed via the foreign function interface to PureScript
--   code, in the same sense as <a>EvalT</a>.
data InterpretT m a

-- | Run a computation in the <a>InterpretT</a> monad, possibly returning
--   an error. Note: errors can occur during module building or evaluation
--   (i.e. module loading).
--   
--   The <a>runInterpret</a> function is a simpler alternative in the case
--   where benign side-effects are not needed.
--   
--   For example:
--   
--   <pre>
--   runInterpret <tt>Module do
--     -- Load the prelude
--     <a>ffi</a> <tt>prelude</tt>
--     -- Build a module from source
--     <a>build</a> "module Main where main = \"example\"" --
--   
--   runInterpret </tt>(Eval Text) do
--     <a>ffi</a> <tt>prelude</tt>
--     _ &lt;- <a>build</a> "module Main where main = \"example\""
--     -- Evaluate the main function
--     <a>evalMain</a> (<a>ModuleName</a> "Main")
--   </pre>
runInterpretT :: Monad m => InterpretT m a -> m (Either (InterpretError m) a)
runInterpret :: Interpret a -> Either (InterpretError Identity) a

-- | A convenience function for running <a>EvalT</a> computations in
--   <a>InterpretT</a>, reporting errors via <a>InterpretError</a>.
liftEvalT :: Monad m => EvalT m a -> InterpretT m a

-- | Like <a>runInterpretT</a>, but starts an interactive debugging session
--   in the event of a debugging error.
runInterpretTWithDebugger :: (MonadIO m, MonadFix m, MonadMask m) => InterpretT m a -> m ()

-- | The type of errors that can occur in the <a>InterpretT</a> monad.
data InterpretError m

-- | Evaluation errors can occur during the initial evaluation of the
--   module when it is loaded into the environment.
ErrorDuringEvaluation :: EvaluationError m -> InterpretError m

-- | Build errors can occur if we are building modules from source or
--   corefn.
ErrorDuringBuild :: BuildError -> InterpretError m
renderInterpretError :: RenderValueOptions -> InterpretError m -> String

-- | Make an <a>FFI</a> module available for use to subsequent operations.
--   
--   For example, to make the <a>prelude</a> available:
--   
--   <pre>
--   ffi <a>prelude</a>
--   </pre>
ffi :: Monad m => FFI m -> InterpretT m ()

-- | Build a PureScript module from source, and make its exported functions
--   available during subsequent evaluations.
build :: MonadFix m => Text -> InterpretT m (Module Ann)

-- | Build a PureScript module from corefn, and make its exported functions
--   available during subsequent evaluations.
--   
--   The corefn module may be preprepared, for example by compiling from
--   source text using the functions in the <a>Dovetail.Build</a> module.
buildCoreFn :: MonadFix m => ExternsFile -> Module Ann -> InterpretT m (Module Ann)
data BuildError
UnableToParse :: NonEmpty ParserError -> BuildError
UnableToCompile :: MultipleErrors -> BuildError
InternalError :: BuildError
renderBuildError :: BuildError -> String

-- | Evaluate a PureScript expression from source
eval :: (MonadFix m, ToValueRHS m a) => Maybe ModuleName -> Text -> InterpretT m (a, SourceType)

-- | Evaluate a PureScript corefn expression and return the result. Note:
--   The expression is not type-checked by the PureScript typechecker. See
--   the documentation for <a>ToValueRHS</a> for valid result types.
evalCoreFn :: (MonadFix m, ToValueRHS m a) => Expr Ann -> InterpretT m a

-- | Evaluate <tt>main</tt> in the specified module and return the result.
evalMain :: (MonadFix m, ToValueRHS m a) => ModuleName -> InterpretT m a

-- | Non-transformer version of <a>EvalT</a>, useful in any settings where
--   the FFI does not use any side effects during evaluation.
type Eval = EvalT Identity

-- | The monad used by the interpreter, which supports error reporting for
--   errors which can occur during evaluation.
--   
--   The transformed monad is used to track any benign side effects that
--   might be exposed via the foreign function interface to PureScript
--   code.
newtype EvalT m a
EvalT :: ReaderT (EvaluationContext m) (ExceptT (EvaluationError m) m) a -> EvalT m a
[unEvalT] :: EvalT m a -> ReaderT (EvaluationContext m) (ExceptT (EvaluationError m) m) a

-- | An environment, i.e. a mapping from names to evaluated values.
--   
--   An environment for a single built-in function can be constructed using
--   the <tt>builtIn</tt> function, and environments can be combined easily
--   using the <a>Monoid</a> instance for <a>Map</a>.
type Env m = Map (Qualified Ident) (Value m)
runEvalT :: EvalT m a -> m (Either (EvaluationError m) a)
runEval :: Eval a -> Either (EvaluationError Identity) a

-- | <a>ToValue</a> should support functions with types such as
--   
--   <pre>
--   a -&gt; EvalT m b
--   a -&gt; b -&gt; EvalT m c
--   a -&gt; b -&gt; c -&gt; EvalT m d
--   (a -&gt; EvalT m b) -&gt; EvalT m c
--   (a -&gt; b -&gt; EvalT m c) -&gt; EvalT m d
--   </pre>
--   
--   Note that every type in a return position is wrapped in the
--   <a>EvalT</a> monad transformer. This is because evaluation in general
--   may result in errors. However, a naive translation would result in too
--   many applications of <a>EvalT</a>.
--   
--   Specifically, we do not want to require types such as these, in which
--   <a>EvalT</a> appears on the right hand side of every function arrow:
--   
--   <pre>
--   a -&gt; EvalT m b (b -&gt; EvalT m c)
--   a -&gt; EvalT m b (b -&gt; EvalT m (c -&gt; EvalT m d))
--   </pre>
--   
--   For this reason, the <a>ToValue</a> instance for functions delegates
--   to this type class for the type on the right hand side of the
--   function. It skips the application of <a>EvalT</a> for nested function
--   types.
class ToValueRHS m a
toValueRHS :: ToValueRHS m a => a -> EvalT m (Value m)
fromValueRHS :: ToValueRHS m a => EvalT m (Value m) -> a

-- | Values which can be communicated across the FFI boundary from Haskell
--   to PureScript.
--   
--   Instances should identify and document any valid representations as a
--   subset of the semantic domain <a>Value</a>. Such a subset can be
--   identified by an injective function <a>toValue</a>, and a partial
--   inverse, <a>fromValue</a>, defined on the image of <a>toValue</a>.
--   
--   Laws:
--   
--   <pre>
--   fromValue . toValue = pure
--   </pre>
class MonadFix m => ToValue m a

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: ToValue m a => a -> Value m

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: (ToValue m a, Generic a, ToObject m (Rep a)) => a -> Value m
fromValue :: ToValue m a => Value m -> EvalT m a
fromValue :: (ToValue m a, Generic a, ToObject m (Rep a)) => Value m -> EvalT m a

-- | Start an interactive debugger (REPL) session.
repl :: (MonadFix m, MonadIO m, MonadMask m) => Maybe ModuleName -> InterpretT m ()
type Ann = (SourceSpan, [Comment], Maybe SourceType, Maybe Meta)
data Expr a
data Module a
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError (Dovetail.InterpretError m) (Dovetail.InterpretT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Dovetail.InterpretT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Dovetail.InterpretT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Dovetail.InterpretT m)
instance Control.Monad.Trans.Class.MonadTrans Dovetail.InterpretT
