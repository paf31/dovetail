-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/paf31/runpurs-hs#readme</a>
@package runpurs-hs
@version 0.1.0.0

module Language.PureScript.Interpreter
type Env m = Map (Qualified Ident) (Value m)
data Value m
Object :: HashMap Text (Value m) -> Value m
Array :: Vector (Value m) -> Value m
String :: Text -> Value m
Number :: Scientific -> Value m
Bool :: Bool -> Value m
Null :: Value m
Closure :: (Value m -> m (Value m)) -> Value m
Constructor :: Constructor m -> Value m
data Constructor m
MkConstructor :: Qualified (ProperName 'ConstructorName) -> [Value m] -> [Ident] -> Constructor m
[ctorName] :: Constructor m -> Qualified (ProperName 'ConstructorName)
[ctorApplied] :: Constructor m -> [Value m]
[ctorUnapplied] :: Constructor m -> [Ident]
data EvalException
UnknownIdent :: Qualified Ident -> EvalException
TypeMismatch :: Text -> EvalException
FieldNotFound :: Text -> EvalException
InexhaustivePatternMatch :: EvalException

-- | TODO: remove this
NotSupported :: Text -> EvalException
InvalidNumberOfArguments :: Int -> Int -> EvalException
UnsaturatedConstructorApplication :: EvalException
InvalidFieldName :: PSString -> EvalException
OtherError :: Text -> EvalException
eval :: forall m. Monad m => ModuleName -> Env m -> Expr () -> m (Value m)
apply :: Monad m => Value m -> Value m -> m (Value m)
interpret :: FromValue m a => Env m -> Module ann -> m a
class Monad m => ToValue m a
toValue :: ToValue m a => a -> Value m
toValue :: (ToValue m a, Generic a, GToObject m (Rep a)) => a -> Value m
class Monad m => FromValue m a
fromValue :: FromValue m a => Value m -> a
fromValue :: (FromValue m a, Generic a, GFromObject m (Rep a)) => Value m -> a
builtIn :: ToValue m a => Text -> a -> Env m
instance GHC.Show.Show Language.PureScript.Interpreter.EvalException
instance (m GHC.Types.~ n, GHC.Base.Monad m, Language.PureScript.Interpreter.FromValue m a, Language.PureScript.Interpreter.ToValue m b) => Language.PureScript.Interpreter.ToValue m (Control.Arrow.Kleisli n a b)
instance (GHC.Base.Monad m, Language.PureScript.Interpreter.FromValue m a, Language.PureScript.Interpreter.ToValue m b) => Language.PureScript.Interpreter.ToValue m (a -> b)
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m (Language.PureScript.Interpreter.Value m)
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m Data.Text.Internal.Text
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m GHC.Integer.Type.Integer
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m Data.Scientific.Scientific
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m GHC.Types.Bool
instance Language.PureScript.Interpreter.FromValue m a => Language.PureScript.Interpreter.FromValue m (GHC.Maybe.Maybe a)
instance Language.PureScript.Interpreter.FromValue m a => Language.PureScript.Interpreter.FromValue m (Data.Vector.Vector a)
instance (m GHC.Types.~ n, Language.PureScript.Interpreter.ToValue m a, Language.PureScript.Interpreter.FromValue m b) => Language.PureScript.Interpreter.FromValue m (Control.Arrow.Kleisli n a b)
instance (m GHC.Types.~ Data.Functor.Identity.Identity, Language.PureScript.Interpreter.ToValue m a, Language.PureScript.Interpreter.FromValue m b) => Language.PureScript.Interpreter.FromValue m (a -> b)
instance (GHC.TypeLits.KnownSymbol field, Language.PureScript.Interpreter.FromValue m a) => Language.PureScript.Interpreter.GFromObject m (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) u s l) (GHC.Generics.K1 r a))
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). Language.PureScript.Interpreter.GFromObject m f => Language.PureScript.Interpreter.GFromObject m (GHC.Generics.M1 GHC.Generics.D t f)
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). Language.PureScript.Interpreter.GFromObject m f => Language.PureScript.Interpreter.GFromObject m (GHC.Generics.M1 GHC.Generics.C t f)
instance forall k (m :: * -> *) (f :: k -> *) (g :: k -> *). (Language.PureScript.Interpreter.GFromObject m f, Language.PureScript.Interpreter.GFromObject m g) => Language.PureScript.Interpreter.GFromObject m (f GHC.Generics.:*: g)
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m (Language.PureScript.Interpreter.Value m)
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m GHC.Integer.Type.Integer
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m Data.Scientific.Scientific
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m Data.Text.Internal.Text
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m GHC.Types.Bool
instance Language.PureScript.Interpreter.ToValue m a => Language.PureScript.Interpreter.ToValue m (GHC.Maybe.Maybe a)
instance Language.PureScript.Interpreter.ToValue m a => Language.PureScript.Interpreter.ToValue m (Data.Vector.Vector a)
instance (GHC.TypeLits.KnownSymbol field, Language.PureScript.Interpreter.ToValue m a) => Language.PureScript.Interpreter.GToObject m (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) u s l) (GHC.Generics.K1 r a))
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). Language.PureScript.Interpreter.GToObject m f => Language.PureScript.Interpreter.GToObject m (GHC.Generics.M1 GHC.Generics.D t f)
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). Language.PureScript.Interpreter.GToObject m f => Language.PureScript.Interpreter.GToObject m (GHC.Generics.M1 GHC.Generics.C t f)
instance forall k (m :: * -> *) (f :: k -> *) (g :: k -> *). (Language.PureScript.Interpreter.GToObject m f, Language.PureScript.Interpreter.GToObject m g) => Language.PureScript.Interpreter.GToObject m (f GHC.Generics.:*: g)
instance GHC.Exception.Type.Exception Language.PureScript.Interpreter.EvalException

module Language.PureScript.Interpreter.JSON
newtype JSON a
JSON :: a -> JSON a
[getJSON] :: JSON a -> a
fromJSON :: Value -> Value m
toJSON :: Value m -> Maybe Value
instance (GHC.Base.Monad m, Data.Aeson.Types.FromJSON.FromJSON a) => Language.PureScript.Interpreter.FromValue m (Language.PureScript.Interpreter.JSON.JSON a)
instance (GHC.Base.Monad m, Data.Aeson.Types.ToJSON.ToJSON a) => Language.PureScript.Interpreter.ToValue m (Language.PureScript.Interpreter.JSON.JSON a)

module Language.PureScript.Make.Simplified
data BuildError
UnableToParse :: NonEmpty ParserError -> BuildError
UnableToCompile :: MultipleErrors -> BuildError
renderBuildError :: BuildError -> String
buildSingleModule :: FilePath -> Text -> IO (Either BuildError (Module Ann))
buildCoreFnOnly :: Env -> [ExternsFile] -> Module -> IO (Either MultipleErrors (Module Ann, MultipleErrors))
