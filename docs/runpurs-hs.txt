-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/paf31/runpurs-hs#readme</a>
@package runpurs-hs
@version 0.1.0.0

module Language.PureScript.Interpreter.FFIBuilder.Internal
forAll :: (SourceType -> SourceType) -> SourceType
array :: SourceType -> SourceType
function :: SourceType -> SourceType -> SourceType

module Language.PureScript.Make.Simplified
data BuildError
UnableToParse :: NonEmpty ParserError -> BuildError
UnableToCompile :: MultipleErrors -> BuildError
renderBuildError :: BuildError -> String

-- | Parse and build a single PureScript module, returning the compiled
--   CoreFn module.
buildSingleModule :: [ExternsFile] -> Text -> Either BuildError (Module Ann, ExternsFile)

-- | Compile a single <a>Module</a> into a CoreFn module.
--   
--   This function is based on the <a>rebuildModule</a> function.
--   
--   It is reproduced and modified here in order to make it simpler to
--   build a single module without all of the additional capabilities and
--   complexity of the upstream API.
buildCoreFnOnly :: [ExternsFile] -> Module -> Either MultipleErrors ((Module Ann, ExternsFile), MultipleErrors)

module Language.PureScript.Interpreter

-- | Build a compiled PureScript <a>Module</a> in the specified
--   environment, returning the output from its main function as a Haskell
--   value.
buildAndEval :: (MonadFix m, ToValueRHS m a) => Env m -> Module ann -> Expr () -> a

-- | Build a compiled PureScript <a>Module</a> in the specified
--   environment, evaluating and returning the output from its main
--   function as a Haskell value.
--   
--   A <a>Module</a> can be obtained by parsing the JSON output of the
--   PureScript compiler (see <a>Language.PureScript.CoreFn.FromJSON</a>),
--   or by using the helper functions in the
--   <a>Language.PureScript.Make.Simplified</a> module to build a module
--   from source.
buildAndEvalMain :: (MonadFix m, ToValueRHS m a) => Env m -> Module ann -> a
runWithFFI :: (MonadFix m, ToValueRHS m a) => [FFI m] -> Text -> Either BuildError a

-- | Evaluate each of the bindings in a compiled PureScript module, and
--   store the evaluated values in the environment, without evaluating any
--   main expression.
build :: MonadFix m => Env m -> Module ann -> EvalT m (Env m)

-- | Create an environment from a Haskell value.
--   
--   It is recommended that a type annotation is given for the type of the
--   value being provided.
--   
--   For example:
--   
--   <pre>
--   builtIn "greeting" ("Hello, World!" :: Text)
--   builtIn "somePrimes" ([2, 3, 5, 7, 11] :: Vector Integer)
--   </pre>
--   
--   Functions can be provided as built-ins, but the <a>EvalT</a> monad
--   needs to be used to wrap any outputs (or values in positive position):
--   
--   <pre>
--   builtIn "strip" ((pure . Text.strip) :: Text -&gt; EvalT m Text)
--   builtIn "map" (traverse :: (Value -&gt; EvalT m Value) -&gt; Vector Value -&gt; EvalT m (Vector Value))
--   </pre>
--   
--   Polymorphic functions can also be provided as built-ins, but values
--   with polymoprhic types will need to be passed across the FFI boundary
--   with monomorphic types. The type <a>Value</a> can always be used to
--   represent values of unknown or polymorphic type, as in the
--   <tt>map</tt> example above.
builtIn :: ToValue m a => ModuleName -> Text -> a -> Env m

-- | The representation of values used by the interpreter - essentially,
--   the semantic domain for a simple untyped lambda calculus with records
--   and ADTs.
--   
--   Any additional side effects which might occur in FFI calls to Haskell
--   code are tracked by a monad in the type argument.
data Value m

-- | Records are represented as hashmaps from their field names to values
Object :: HashMap Text (Value m) -> Value m

-- | Arrays
Array :: Vector (Value m) -> Value m
String :: Text -> Value m

-- | Numeric values
--   
--   TODO: separate integers from floating-point values
Number :: Scientific -> Value m
Bool :: Bool -> Value m

-- | Closures, represented in higher-order abstract syntax style.
Closure :: (Value m -> EvalT m (Value m)) -> Value m

-- | Fully-applied data constructors
Constructor :: Qualified (ProperName 'ConstructorName) -> [Value m] -> Value m

-- | The monad used by the interpreter, which supports error reporting for
--   errors which can occur during evaluation.
--   
--   The transformed monad is used to track any benign side effects that
--   might be exposed via the foreign function interface to PureScript
--   code.
newtype EvalT m a
EvalT :: ExceptT EvaluationError m a -> EvalT m a
[unEvalT] :: EvalT m a -> ExceptT EvaluationError m a
runEvalT :: EvalT m a -> m (Either EvaluationError a)

-- | Non-transformer version of <a>EvalT</a>, useful in any settings where
--   the FFI does not use any side effects during evaluation.
type Eval = EvalT Identity
runEval :: Eval a -> Either EvaluationError a

-- | Errors which can occur during evaluation of PureScript code.
--   
--   PureScript is a typed language, and tries to prevent runtime errors.
--   However, in the context of this interpreter, we can receive data from
--   outside PureScript code, so it is possible that runtime errors can
--   occur if we are not careful. This is similar to how PureScript code
--   can fail at runtime due to errors in the FFI.
data EvaluationError

-- | A name was not found in the environment
UnknownIdent :: Qualified Ident -> EvaluationError

-- | The runtime representation of a value did not match the expected
--   representation
TypeMismatch :: Text -> EvaluationError

-- | A record field did not exist in an <a>Object</a> value.
FieldNotFound :: Text -> EvaluationError

-- | A pattern match failed to match its argument
InexhaustivePatternMatch :: EvaluationError

-- | A pattern match received the wrong number of arguments
InvalidNumberOfArguments :: Int -> Int -> EvaluationError

-- | A pattern match occurred against a partially-applied data constructor
UnsaturatedConstructorApplication :: EvaluationError

-- | A PureScript string which contains lone surrogates which could not be
--   decoded. See <a>PSString</a>.
InvalidFieldName :: PSString -> EvaluationError

-- | An error occurred in a foreign function which is not tracked by any of
--   the other error types.
--   
--   TODO: remove this in favor of using monadic FFI functions
OtherError :: Text -> EvaluationError

-- | Render an <a>EvaluationError</a> as a human-readable string.
renderEvaluationError :: EvaluationError -> String

-- | An environment, i.e. a mapping from names to evaluated values.
--   
--   An environment for a single built-in function can be constructed using
--   the <a>builtIn</a> function, and environments can be combined easily
--   using the <a>Monoid</a> instance for <a>Map</a>.
type Env m = Map (Qualified Ident) (Value m)

-- | Evaluate a PureScript CoreFn expression in the given environment.
--   
--   Note: it should not be necessary to call this function directly in
--   most circumstances. It is provided as a helper function, for some more
--   advanced use cases, such as setting up a custom environment.
eval :: forall m. MonadFix m => ModuleName -> Env m -> Expr () -> EvalT m (Value m)

-- | Apply a value which represents an unevaluated closure to an argument.
apply :: MonadFix m => Value m -> Value m -> EvalT m (Value m)
data FFI m
FFI :: ModuleName -> [ForeignImport m] -> FFI m
[ffi_moduleName] :: FFI m -> ModuleName
[ffi_values] :: FFI m -> [ForeignImport m]
data ForeignImport m
ForeignImport :: Ident -> SourceType -> Value m -> ForeignImport m
[fv_name] :: ForeignImport m -> Ident
[fv_type] :: ForeignImport m -> SourceType
[fv_value] :: ForeignImport m -> Value m
toEnv :: FFI m -> Env m
toExterns :: FFI m -> ExternsFile

-- | Values which can be communicated across the FFI boundary from Haskell
--   to PureScript.
--   
--   Instances should identify and document any valid representations as a
--   subset of the semantic domain <a>Value</a>. Such a subset can be
--   identified by an injective function <a>toValue</a>, and a partial
--   inverse, <a>fromValue</a>, defined on the image of <a>toValue</a>.
--   
--   Laws:
--   
--   <pre>
--   fromValue . toValue = pure
--   </pre>
class MonadFix m => ToValue m a

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: ToValue m a => a -> Value m

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: (ToValue m a, Generic a, ToObject m (Rep a)) => a -> Value m
fromValue :: ToValue m a => Value m -> EvalT m a
fromValue :: (ToValue m a, Generic a, ToObject m (Rep a)) => Value m -> EvalT m a

-- | <a>ToValue</a> should support functions with types such as
--   
--   <pre>
--   a -&gt; EvalT m b
--   a -&gt; b -&gt; EvalT m c
--   a -&gt; b -&gt; c -&gt; EvalT m d
--   (a -&gt; EvalT m b) -&gt; EvalT m c
--   (a -&gt; b -&gt; EvalT m c) -&gt; EvalT m d
--   </pre>
--   
--   Note that every type in a return position is wrapped in the
--   <a>EvalT</a> monad transformer. This is because evaluation in general
--   may result in errors. However, a naive translation would result in too
--   many applications of <a>EvalT</a>.
--   
--   Specifically, we do not want to require types such as these, in which
--   <a>EvalT</a> appears on the right hand side of every function arrow:
--   
--   <pre>
--   a -&gt; EvalT m b (b -&gt; EvalT m c)
--   a -&gt; EvalT m b (b -&gt; EvalT m (c -&gt; EvalT m d))
--   </pre>
--   
--   For this reason, the <a>ToValue</a> instance for functions delegates
--   to this type class for the type on the right hand side of the
--   function. It skips the application of <a>EvalT</a> for nested function
--   types.
class ToValueRHS m a
toValueRHS :: ToValueRHS m a => a -> EvalT m (Value m)
fromValueRHS :: ToValueRHS m a => EvalT m (Value m) -> a

-- | Options for customizing generic deriving of record instances
data ObjectOptions
ObjectOptions :: (Text -> Text) -> ObjectOptions

-- | Map a Haskell field name to a PureScript field name on the
--   corresponding record type.
[toPureScriptField] :: ObjectOptions -> Text -> Text

-- | <ul>
--   <li>Maps Haskell field names to PureScript field names,
--   unmodified.</li>
--   </ul>
defaultObjectOptions :: ObjectOptions

-- | Derived <a>toValue</a> function for Haskell record types which should
--   map to corresponding PureScript record types.
genericToValue :: (MonadFix m, Generic a, ToObject m (Rep a)) => ObjectOptions -> a -> Value m

-- | Derived <a>fromValue</a> function for Haskell record types which
--   should map to corresponding PureScript record types.
genericFromValue :: (MonadFix m, Generic a, ToObject m (Rep a)) => ObjectOptions -> Value m -> EvalT m a

-- | This class is used in the default instance for <a>ToValue</a>, via
--   generic deriving, in order to identify a Haskell record type (with a
--   single data constructor and named fields) with values in the semantic
--   domain corresponding to a PureScript record type with the same field
--   names.
class ToObject m f
toObject :: ToObject m f => ObjectOptions -> f x -> HashMap Text (Value m)
fromObject :: ToObject m f => ObjectOptions -> HashMap Text (Value m) -> EvalT m (f x)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Language.PureScript.Interpreter.EvalT m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Language.PureScript.Interpreter.EvaluationError (Language.PureScript.Interpreter.EvalT m)
instance Control.Monad.Trans.Class.MonadTrans Language.PureScript.Interpreter.EvalT
instance GHC.Base.Monad m => GHC.Base.Monad (Language.PureScript.Interpreter.EvalT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Language.PureScript.Interpreter.EvalT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.PureScript.Interpreter.EvalT m)
instance Control.Monad.Fix.MonadFix m => Language.PureScript.Interpreter.ToValue m (Language.PureScript.Interpreter.Value m)
instance Control.Monad.Fix.MonadFix m => Language.PureScript.Interpreter.ToValue m GHC.Integer.Type.Integer
instance Control.Monad.Fix.MonadFix m => Language.PureScript.Interpreter.ToValue m Data.Scientific.Scientific
instance Control.Monad.Fix.MonadFix m => Language.PureScript.Interpreter.ToValue m Data.Text.Internal.Text
instance Control.Monad.Fix.MonadFix m => Language.PureScript.Interpreter.ToValue m GHC.Types.Bool
instance (Control.Monad.Fix.MonadFix m, Language.PureScript.Interpreter.ToValue m a, Language.PureScript.Interpreter.ToValueRHS m b) => Language.PureScript.Interpreter.ToValue m (a -> b)
instance Language.PureScript.Interpreter.ToValue m a => Language.PureScript.Interpreter.ToValue m (Data.Vector.Vector a)
instance (Control.Monad.Fix.MonadFix m, Language.PureScript.Interpreter.ToValue m a, Language.PureScript.Interpreter.ToValueRHS m b) => Language.PureScript.Interpreter.ToValueRHS m (a -> b)
instance (Language.PureScript.Interpreter.ToValue m a, n GHC.Types.~ m) => Language.PureScript.Interpreter.ToValueRHS m (Language.PureScript.Interpreter.EvalT n a)
instance (GHC.TypeLits.KnownSymbol field, Language.PureScript.Interpreter.ToValue m a) => Language.PureScript.Interpreter.ToObject m (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) u s l) (GHC.Generics.K1 r a))
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). (GHC.Base.Functor m, Language.PureScript.Interpreter.ToObject m f) => Language.PureScript.Interpreter.ToObject m (GHC.Generics.M1 GHC.Generics.D t f)
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). (GHC.Base.Functor m, Language.PureScript.Interpreter.ToObject m f) => Language.PureScript.Interpreter.ToObject m (GHC.Generics.M1 GHC.Generics.C t f)
instance forall k (m :: * -> *) (f :: k -> *) (g :: k -> *). (Control.Monad.Fix.MonadFix m, Language.PureScript.Interpreter.ToObject m f, Language.PureScript.Interpreter.ToObject m g) => Language.PureScript.Interpreter.ToObject m (f GHC.Generics.:*: g)

module Language.PureScript.Interpreter.Monad
data InterpretT m a
runInterpretT :: Monad m => InterpretT m a -> m a
runInterpret :: Interpret a -> a
ffi :: Monad m => FFI m -> InterpretT m ()
data BuildError
renderBuildError :: BuildError -> String
build :: MonadFix m => Text -> InterpretT m (Either BuildError (Module Ann))
eval :: (MonadFix m, ToValueRHS m a) => Expr () -> InterpretT m a
evalMain :: (MonadFix m, ToValueRHS m a) => ModuleName -> InterpretT m a
instance GHC.Base.Monad m => GHC.Base.Monad (Language.PureScript.Interpreter.Monad.InterpretT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Language.PureScript.Interpreter.Monad.InterpretT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.PureScript.Interpreter.Monad.InterpretT m)
instance Control.Monad.Trans.Class.MonadTrans Language.PureScript.Interpreter.Monad.InterpretT

module Language.PureScript.Interpreter.JSON
newtype JSON a
JSON :: a -> JSON a
[getJSON] :: JSON a -> a
fromJSON :: Value -> Value m
toJSON :: Value m -> Maybe Value
instance (Control.Monad.Fix.MonadFix m, Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.FromJSON.FromJSON a) => Language.PureScript.Interpreter.ToValue m (Language.PureScript.Interpreter.JSON.JSON a)

module Language.PureScript.Interpreter.FFIBuilder
data FFIBuilder m a
runFFIBuilder :: ModuleName -> FFIBuilder m a -> (a, FFI m)
evalFFIBuilder :: ModuleName -> FFIBuilder m a -> FFI m
foreignImport :: (MonadFix m, ToValue m a, ForAll m a ty) => Ident -> ty -> a -> FFIBuilder m ()
data FunctionType m l r
string :: FunctionType m Text (EvalT m Text)
boolean :: FunctionType m Bool (EvalT m Bool)
number :: FunctionType m Scientific (EvalT m Scientific)
array :: FunctionType m l r -> FunctionType m (Vector l) (EvalT m (Vector l))
(~>) :: FunctionType m al ar -> FunctionType m bl br -> FunctionType m (al -> br) (al -> br)
infixr 0 ~>
class ForAll m r a | a -> m r
instance Control.Monad.Writer.Class.MonadWriter (Language.PureScript.Interpreter.FFIBuilder.FFI_ m) (Language.PureScript.Interpreter.FFIBuilder.FFIBuilder m)
instance GHC.Base.Monad (Language.PureScript.Interpreter.FFIBuilder.FFIBuilder m)
instance GHC.Base.Applicative (Language.PureScript.Interpreter.FFIBuilder.FFIBuilder m)
instance GHC.Base.Functor (Language.PureScript.Interpreter.FFIBuilder.FFIBuilder m)
instance GHC.Base.Semigroup (Language.PureScript.Interpreter.FFIBuilder.FFI_ m)
instance GHC.Base.Monoid (Language.PureScript.Interpreter.FFIBuilder.FFI_ m)
instance Language.PureScript.Interpreter.FFIBuilder.ForAll m a (Language.PureScript.Interpreter.FFIBuilder.FunctionType m a r_)
instance (Language.PureScript.Interpreter.FFIBuilder.ForAll m r o, a GHC.Types.~ Language.PureScript.Interpreter.FFIBuilder.FunctionType m (Language.PureScript.Interpreter.Value m) (Language.PureScript.Interpreter.EvalT m (Language.PureScript.Interpreter.Value m))) => Language.PureScript.Interpreter.FFIBuilder.ForAll m r (a -> o)

module Language.PureScript.Interpreter.Prelude
prelude :: MonadFix m => FFI m
