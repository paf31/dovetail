-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A PureScript interpreter with a Haskell FFI.
--   
--   Dovetail is a general-purpose PureScript corefn interpreter with an
--   FFI to Haskell. Please see the README on GitHub at
--   <a>https://github.com/paf31/dovetail#readme</a>, or check out the
--   examples directory, to learn how to use the library.
@package dovetail
@version 0.1.1.0

module Dovetail.Build
data BuildError
UnableToParse :: NonEmpty ParserError -> BuildError
UnableToCompile :: MultipleErrors -> BuildError
InternalError :: BuildError
renderBuildError :: BuildError -> String

-- | Parse and build a single PureScript module, returning the compiled
--   CoreFn module.
buildSingleModule :: [ExternsFile] -> Text -> Either BuildError (Module Ann, ExternsFile)

-- | Parse and build a single PureScript expression, returning the compiled
--   CoreFn module. The expression will be used to create a placeholder
--   module with the name <tt>Main</tt>, and a single expression named
--   <tt>main</tt>, with the specified content.
buildSingleExpression :: Maybe ModuleName -> [ExternsFile] -> Text -> Either BuildError (Expr Ann, SourceType)
buildSingleExpressionWith :: (Expr -> Expr) -> Maybe ModuleName -> [ExternsFile] -> Text -> Either BuildError (Expr Ann, SourceType)
buildSingleExpressionFromAST :: Maybe ModuleName -> [ExternsFile] -> Expr -> Either BuildError (Expr Ann, SourceType)

-- | Compile a single <a>Module</a> into a CoreFn module.
--   
--   This function is based on the <a>rebuildModule</a> function.
--   
--   It is reproduced and modified here in order to make it simpler to
--   build a single module without all of the additional capabilities and
--   complexity of the upstream API.
buildCoreFnOnly :: [ExternsFile] -> Module -> Either MultipleErrors ((Module Ann, ExternsFile), MultipleErrors)
instance GHC.Show.Show Dovetail.Build.BuildError

module Dovetail.Evaluate.Internal
data Promise a
emptyPromise :: IO (Promise a)
require :: Promise a -> IO a
fulfill :: Promise a -> a -> IO ()
data EmptyPromise
EmptyPromise :: EmptyPromise
instance GHC.Show.Show Dovetail.Evaluate.Internal.EmptyPromise
instance GHC.Exception.Type.Exception Dovetail.Evaluate.Internal.EmptyPromise

module Dovetail.FFI.Internal
forAll :: (SourceType -> SourceType) -> SourceType
array :: SourceType -> SourceType
function :: SourceType -> SourceType -> SourceType

module Dovetail.Types

-- | The representation of values used by the interpreter - essentially,
--   the semantic domain for a simple untyped lambda calculus with records
--   and ADTs.
--   
--   Any additional side effects which might occur in FFI calls to Haskell
--   code are tracked by a monad in the type argument.
data Value ctx

-- | Records are represented as hashmaps from their field names to values
Object :: HashMap Text (Value ctx) -> Value ctx
Array :: Vector (Value ctx) -> Value ctx
String :: Text -> Value ctx
Char :: Char -> Value ctx
Number :: Double -> Value ctx
Int :: Integer -> Value ctx
Bool :: Bool -> Value ctx

-- | Closures, represented in higher-order abstract syntax style.
Closure :: (Value ctx -> Eval ctx (Value ctx)) -> Value ctx

-- | Fully-applied data constructors
Constructor :: ProperName 'ConstructorName -> [Value ctx] -> Value ctx

-- | Foreign data types
Foreign :: Dynamic -> Value ctx

-- | An environment, i.e. a mapping from names to evaluated values.
--   
--   An environment for a single built-in function can be constructed using
--   the <tt>builtIn</tt> function, and environments can be combined easily
--   using the <a>Monoid</a> instance for <a>Map</a>.
data Env ctx
lookupEnv :: Qualified Ident -> Env ctx -> Maybe (Value ctx)
envNames :: Env ctx -> Set (Qualified Ident)
envToMap :: Env ctx -> Map (Qualified Ident) (Value ctx)
envFromMap :: Map (Qualified Ident) (Value ctx) -> Env ctx
bindEnv :: [(Qualified Ident, Value ctx)] -> Env ctx -> Env ctx

-- | The monad used by the interpreter, which supports error reporting for
--   errors which can occur during evaluation.
--   
--   The transformed monad is used to track any benign side effects that
--   might be exposed via the foreign function interface to PureScript
--   code.
newtype Eval ctx a
Eval :: ReaderT (EvaluationContext ctx) (ExceptT (EvaluationError ctx) IO) a -> Eval ctx a
[unEval] :: Eval ctx a -> ReaderT (EvaluationContext ctx) (ExceptT (EvaluationError ctx) IO) a
runEval :: ctx -> Eval ctx a -> IO (Either (EvaluationError ctx) a)

-- | An evaluation error containing the evaluation context at the point the
--   error was raised.
data EvaluationError ctx
EvaluationError :: EvaluationErrorType ctx -> EvaluationContext ctx -> EvaluationError ctx

-- | The type of error which was raised
[errorType] :: EvaluationError ctx -> EvaluationErrorType ctx

-- | The evaluation context at the point the error was raised.
[errorContext] :: EvaluationError ctx -> EvaluationContext ctx

-- | Errors which can occur during evaluation of PureScript code.
--   
--   PureScript is a typed language, and tries to prevent runtime errors.
--   However, in the context of this interpreter, we can receive data from
--   outside PureScript code, so it is possible that runtime errors can
--   occur if we are not careful. This is similar to how PureScript code
--   can fail at runtime due to errors in the FFI.
data EvaluationErrorType ctx

-- | A name was not found in the environment
UnknownIdent :: Qualified Ident -> EvaluationErrorType ctx

-- | The runtime representation of a value did not match the expected
--   representation
TypeMismatch :: Text -> Value ctx -> EvaluationErrorType ctx

-- | A record field did not exist in an <a>Object</a> value.
FieldNotFound :: Text -> Value ctx -> EvaluationErrorType ctx

-- | A pattern match failed to match its argument
InexhaustivePatternMatch :: [Value ctx] -> EvaluationErrorType ctx

-- | A pattern match received the wrong number of arguments
InvalidNumberOfArguments :: Int -> Int -> EvaluationErrorType ctx

-- | A pattern match occurred against a partially-applied data constructor
UnsaturatedConstructorApplication :: EvaluationErrorType ctx

-- | A PureScript string which contains lone surrogates which could not be
--   decoded. See <a>PSString</a>.
InvalidFieldName :: PSString -> EvaluationErrorType ctx

-- | An error occurred in a foreign function which is not tracked by any of
--   the other error types.
OtherError :: Text -> EvaluationErrorType ctx

-- | Render an <a>EvaluationError</a> as a human-readable string.
renderEvaluationError :: RenderValueOptions -> EvaluationError ctx -> String
renderEvaluationErrorType :: RenderValueOptions -> EvaluationErrorType ctx -> String

-- | An evaluation context currently consists of an evaluation stack, which
--   is only used for debugging purposes, plus any other domain-specific
--   context of type <tt>ctx</tt>.
--   
--   The context type is parameterized by a monad <tt>m</tt>, because stack
--   frames can contain environments, which can in turn contain
--   <a>Value</a>s, which may contain monadic closures. This can be useful
--   for inspecting values or resuming execution in the event of an error.
data EvaluationContext ctx
EvaluationContext :: [EvaluationStackFrame ctx] -> ctx -> EvaluationContext ctx
[callStack] :: EvaluationContext ctx -> [EvaluationStackFrame ctx]
[additionalContext] :: EvaluationContext ctx -> ctx

-- | A single evaluation stack frame TODO: support frames for foreign
--   function calls
data EvaluationStackFrame ctx
EvaluationStackFrame :: Env ctx -> SourceSpan -> Expr Ann -> EvaluationStackFrame ctx

-- | The current environment in this stack frame
[frameEnv] :: EvaluationStackFrame ctx -> Env ctx

-- | The source span of the expression whose evaluation created this stack
--   frame.
[frameSource] :: EvaluationStackFrame ctx -> SourceSpan

-- | The expression whose evaluation created this stack frame.
[frameExpr] :: EvaluationStackFrame ctx -> Expr Ann

-- | Create a stack frame for the evaluation of an expression, and push it
--   onto the stack.
pushStackFrame :: Env ctx -> Expr Ann -> Eval ctx a -> Eval ctx a

-- | Throw an error which captures the current execution context.
throwErrorWithContext :: (MonadError (EvaluationError x) m, MonadReader (EvaluationContext x) m) => EvaluationErrorType x -> m a
renderEvaluationStack :: [EvaluationStackFrame ctx] -> Text

-- | Render a <a>Value</a> as human-readable text.
--   
--   As a general rule, apart from any closures, the rendered text should
--   evaluate to the value you started with (when <a>maximumDepth</a> is
--   not set).
renderValue :: RenderValueOptions -> Value ctx -> Text

-- | Options when rendering values as strings using <a>renderValue</a>.
data RenderValueOptions
RenderValueOptions :: Bool -> Maybe Int -> RenderValueOptions

-- | Should ANSI terminal color codes be emitted
[colorOutput] :: RenderValueOptions -> Bool

-- | The maximum depth of a subexpression to render, or <a>Nothing</a> to
--   render the entire <a>Value</a>.
[maximumDepth] :: RenderValueOptions -> Maybe Int

-- | Some sensible default rendering options for use on a terminal which
--   supports color.
defaultTerminalRenderValueOptions :: RenderValueOptions
instance GHC.Base.Monoid (Dovetail.Types.Env ctx)
instance GHC.Base.Semigroup (Dovetail.Types.Env ctx)
instance Control.Monad.Fix.MonadFix (Dovetail.Types.Eval ctx)
instance Control.Monad.IO.Class.MonadIO (Dovetail.Types.Eval ctx)
instance Control.Monad.Reader.Class.MonadReader (Dovetail.Types.EvaluationContext ctx) (Dovetail.Types.Eval ctx)
instance Control.Monad.Error.Class.MonadError (Dovetail.Types.EvaluationError ctx) (Dovetail.Types.Eval ctx)
instance GHC.Base.Monad (Dovetail.Types.Eval ctx)
instance GHC.Base.Applicative (Dovetail.Types.Eval ctx)
instance GHC.Base.Functor (Dovetail.Types.Eval ctx)

module Dovetail.FFI

-- | Describes a module which is implemented in Haskell, and made available
--   to PureScript code using its foreign function interface.
--   
--   Right now, this consists only of foreign value declarations, even
--   though the FFI supports other forms of interop.
--   
--   Values of this type can be constructed directly, but in many cases it
--   is simpler to use the <a>Dovetail.FFI.Builder</a> module instead.
--   
--   Values of this type can be consumed by the <a>toExterns</a> and
--   <a>toEnv</a> functions, and their results passed to the PureScript
--   APIs or the low-level functions in <a>Dovetail.Evaluate</a> and
--   <a>Dovetail.Build</a>, directly, but it is more likely that you will
--   use values of this type with the higher-level <a>ffi</a> function.
data FFI ctx
FFI :: ModuleName -> [ForeignImport ctx] -> FFI ctx

-- | The module name for the module being implemented in Haskell.
[ffi_moduleName] :: FFI ctx -> ModuleName

-- | A list of values implemented in Haskell in this module.
[ffi_values] :: FFI ctx -> [ForeignImport ctx]

-- | A single value implemented in a foreign Haskell module.
data ForeignImport ctx
ForeignImport :: Ident -> SourceType -> Value ctx -> ForeignImport ctx

-- | The name of this value in PureScript code
[fv_name] :: ForeignImport ctx -> Ident

-- | The PureScript type of this value
[fv_type] :: ForeignImport ctx -> SourceType

-- | The value itself
[fv_value] :: ForeignImport ctx -> Value ctx

-- | Convert a foreign module into an evaluation environment.
--   
--   For advanced use cases, the result may be used with the functions in
--   the <a>Dovetail.Evaluate</a> module.
toEnv :: FFI ctx -> Env ctx

-- | Convert a foreign module into a PureScript externs file, for use
--   during separate compilation.
--   
--   For advanced use cases, the result may be used with the functions in
--   the <a>Dovetail.Build</a> module.
toExterns :: FFI ctx -> ExternsFile

module Dovetail.Evaluate

-- | Evaluate each of the bindings in a compiled PureScript module, and
--   store the evaluated values in the environment, without evaluating any
--   main expression.
buildCoreFn :: Env ctx -> Module Ann -> Eval ctx (Env ctx)

-- | Create an environment from a Haskell value.
--   
--   It is recommended that a type annotation is given for the type of the
--   value being provided.
--   
--   For example:
--   
--   <pre>
--   builtIn (ModuleName <a>Main</a>) "greeting" ("Hello, World!" :: Text)
--   builtIn (ModuleName <a>Main</a>) "somePrimes" ([2, 3, 5, 7, 11] :: Vector Integer)
--   </pre>
--   
--   Functions can be provided as built-ins, but the <tt>EvalT</tt> monad
--   needs to be used to wrap any outputs (or values in positive position):
--   
--   <pre>
--   builtIn (ModuleName <a>Main</a>) "strip" ((pure . Text.strip) :: Text -&gt; Eval ctx Text)
--   builtIn (ModuleName <a>Main</a>) "map" (traverse :: (Value -&gt; Eval ctx Value) -&gt; Vector Value -&gt; Eval ctx (Vector Value))
--   </pre>
--   
--   Polymorphic functions can also be provided as built-ins, but values
--   with polymoprhic types will need to be passed across the FFI boundary
--   with monomorphic types. The type <a>Value</a> can always be used to
--   represent values of unknown or polymorphic type, as in the
--   <tt>map</tt> example above.
builtIn :: ToValue ctx a => ModuleName -> Text -> a -> Env ctx

-- | Evaluate a PureScript CoreFn expression in the given environment.
--   
--   Note: it should not be necessary to call this function directly in
--   most circumstances. It is provided as a helper function, for some more
--   advanced use cases, such as setting up a custom environment.
eval :: forall ctx. Env ctx -> Expr Ann -> Eval ctx (Value ctx)

-- | Apply a value which represents an unevaluated closure to an argument.
apply :: Value ctx -> Value ctx -> Eval ctx (Value ctx)

-- | Values which can be communicated across the FFI boundary from Haskell
--   to PureScript.
--   
--   Instances should identify and document any valid representations as a
--   subset of the semantic domain <a>Value</a>. Such a subset can be
--   identified by an injective function <a>toValue</a>, and a partial
--   inverse, <a>fromValue</a>, defined on the image of <a>toValue</a>.
--   
--   Laws:
--   
--   <pre>
--   fromValue . toValue = pure
--   </pre>
class ToValue ctx a

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: ToValue ctx a => a -> Value ctx

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: (ToValue ctx a, Generic a, ToObject ctx (Rep a)) => a -> Value ctx
fromValue :: ToValue ctx a => Value ctx -> Eval ctx a
fromValue :: (ToValue ctx a, Generic a, ToObject ctx (Rep a)) => Value ctx -> Eval ctx a

-- | <a>ToValue</a> should support functions with types such as
--   
--   <pre>
--   a -&gt; Eval ctx b
--   a -&gt; b -&gt; Eval ctx c
--   a -&gt; b -&gt; c -&gt; Eval ctx d
--   (a -&gt; Eval ctx b) -&gt; Eval ctx c
--   (a -&gt; b -&gt; Eval ctx c) -&gt; Eval ctx d
--   </pre>
--   
--   Note that every type in a return position is wrapped in the
--   <tt>EvalT</tt> monad transformer. This is because evaluation in
--   general may result in errors. However, a naive translation would
--   result in too many applications of <tt>EvalT</tt>.
--   
--   Specifically, we do not want to require types such as these, in which
--   <tt>EvalT</tt> appears on the right hand side of every function arrow:
--   
--   <pre>
--   a -&gt; Eval ctx b (b -&gt; Eval ctx c)
--   a -&gt; Eval ctx b (b -&gt; Eval ctx (c -&gt; Eval ctx d))
--   </pre>
--   
--   For this reason, the <a>ToValue</a> instance for functions delegates
--   to this type class for the type on the right hand side of the
--   function. It skips the application of <a>Eval</a> for nested function
--   types.
class ToValueRHS ctx a
toValueRHS :: ToValueRHS ctx a => a -> Eval ctx (Value ctx)
fromValueRHS :: ToValueRHS ctx a => Eval ctx (Value ctx) -> a

-- | This type can be used to make custom Haskell types accessible to
--   PureScript code via the FFI's <tt>foreign import data</tt> feature.
newtype ForeignType a
ForeignType :: a -> ForeignType a
[getForeignType] :: ForeignType a -> a

-- | Options for customizing generic deriving of record instances
data ObjectOptions
ObjectOptions :: (Text -> Text) -> ObjectOptions

-- | Map a Haskell field name to a PureScript field name on the
--   corresponding record type.
[toPureScriptField] :: ObjectOptions -> Text -> Text

-- | <ul>
--   <li>Maps Haskell field names to PureScript field names,
--   unmodified.</li>
--   </ul>
defaultObjectOptions :: ObjectOptions

-- | Derived <a>toValue</a> function for Haskell record types which should
--   map to corresponding PureScript record types.
genericToValue :: (Generic a, ToObject ctx (Rep a)) => ObjectOptions -> a -> Value ctx

-- | Derived <a>fromValue</a> function for Haskell record types which
--   should map to corresponding PureScript record types.
genericFromValue :: (Generic a, ToObject ctx (Rep a)) => ObjectOptions -> Value ctx -> Eval ctx a

-- | This class is used in the default instance for <a>ToValue</a>, via
--   generic deriving, in order to identify a Haskell record type (with a
--   single data constructor and named fields) with values in the semantic
--   domain corresponding to a PureScript record type with the same field
--   names.
class ToObject ctx f
toObject :: ToObject ctx f => ObjectOptions -> f x -> HashMap Text (Value ctx)
fromObject :: ToObject ctx f => ObjectOptions -> HashMap Text (Value ctx) -> Eval ctx (f x)
evalPSString :: PSString -> Eval ctx Text
instance (ctx GHC.Types.~ ctx') => Dovetail.Evaluate.ToValue ctx (Dovetail.Types.Value ctx')
instance Dovetail.Evaluate.ToValue ctx GHC.Integer.Type.Integer
instance Dovetail.Evaluate.ToValue ctx GHC.Types.Double
instance Dovetail.Evaluate.ToValue ctx Data.Text.Internal.Text
instance Dovetail.Evaluate.ToValue ctx GHC.Types.Char
instance Dovetail.Evaluate.ToValue ctx GHC.Types.Bool
instance (Dovetail.Evaluate.ToValue ctx a, Dovetail.Evaluate.ToValueRHS ctx b) => Dovetail.Evaluate.ToValue ctx (a -> b)
instance Dovetail.Evaluate.ToValue ctx a => Dovetail.Evaluate.ToValue ctx (Data.Vector.Vector a)
instance (k GHC.Types.~ Data.Text.Internal.Text, Dovetail.Evaluate.ToValue ctx a) => Dovetail.Evaluate.ToValue ctx (Data.HashMap.Internal.HashMap k a)
instance Data.Typeable.Internal.Typeable a => Dovetail.Evaluate.ToValue ctx (Dovetail.Evaluate.ForeignType a)
instance (Dovetail.Evaluate.ToValue ctx a, Dovetail.Evaluate.ToValueRHS ctx b) => Dovetail.Evaluate.ToValueRHS ctx (a -> b)
instance (Dovetail.Evaluate.ToValue ctx a, ctx GHC.Types.~ ctx') => Dovetail.Evaluate.ToValueRHS ctx (Dovetail.Types.Eval ctx' a)
instance (GHC.TypeLits.KnownSymbol field, Dovetail.Evaluate.ToValue ctx a) => Dovetail.Evaluate.ToObject ctx (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) u s l) (GHC.Generics.K1 r a))
instance forall k ctx (f :: k -> *) (t :: GHC.Generics.Meta). Dovetail.Evaluate.ToObject ctx f => Dovetail.Evaluate.ToObject ctx (GHC.Generics.M1 GHC.Generics.D t f)
instance forall k ctx (f :: k -> *) (t :: GHC.Generics.Meta). Dovetail.Evaluate.ToObject ctx f => Dovetail.Evaluate.ToObject ctx (GHC.Generics.M1 GHC.Generics.C t f)
instance forall k ctx (f :: k -> *) (g :: k -> *). (Dovetail.Evaluate.ToObject ctx f, Dovetail.Evaluate.ToObject ctx g) => Dovetail.Evaluate.ToObject ctx (f GHC.Generics.:*: g)

module Dovetail.REPL

-- | Starts a minimal interactive debugger (REPL) session.
--   
--   It is more likely that you will want to use the <a>repl</a> function
--   to start a REPL session from within an <a>InterpretT</a> block.
defaultMain :: forall ctx. Maybe ModuleName -> [ExternsFile] -> [Ident] -> Env ctx -> ctx -> IO ()


-- | This module provides a higher-level API on top of the
--   <a>Dovetail.FFI</a> module. It is not as expressive as the functions
--   in that module, but has the benefit that it is much harder to use this
--   module to construct an FFI which will result in runtime errors, since
--   it attempts to synthesize the types of the Haskell implementations
--   from the types of the declared PureScript foreign imports.
module Dovetail.FFI.Builder

-- | A monad for constructing <a>FFI</a> data structures.
--   
--   For example:
--   
--   <pre>
--   FFI.<a>evalFFIBuilder</a> (<a>ModuleName</a> "Example") do
--     FFI.<a>foreignImport</a> (P.Ident "example")
--       (a -&gt; a ~&gt; a)
--       pure
--   </pre>
data FFIBuilder ctx a

-- | Run a computation in the <a>FFIBuilder</a> monad, returning the result
--   of the computation alongside the constructed <a>FFI</a>.
runFFIBuilder :: ModuleName -> FFIBuilder ctx a -> (a, FFI ctx)

-- | Run a computation in the <a>FFIBuilder</a> monad, returning only the
--   constructed <a>FFI</a>.
evalFFIBuilder :: ModuleName -> FFIBuilder ctx a -> FFI ctx

-- | Define a value which will be implemented in Haskell.
--   
--   The first argument gives a name to the value on the PureScript side.
--   
--   The second argument is a function which describes its PureScript type.
--   See <a>ForAll</a> for an explanation of its purpose.
--   
--   The final argument is the Haskell implementation of the value.
--   
--   The type checker will ensure that the PureScript and Haskell types are
--   compatible.
foreignImport :: (ToValue ctx a, ForAll ctx a ty) => Ident -> ty -> a -> FFIBuilder ctx ()
data FunctionType ctx l r

-- | The PureScript string type
string :: FunctionType ctx Text (Eval ctx Text)

-- | The PureScript char type
char :: FunctionType ctx Char (Eval ctx Char)

-- | The PureScript boolean type
boolean :: FunctionType ctx Bool (Eval ctx Bool)

-- | The PureScript number type
number :: FunctionType ctx Double (Eval ctx Double)

-- | The PureScript integer type
int :: FunctionType ctx Integer (Eval ctx Integer)

-- | Construct a PureScript array type
array :: FunctionType ctx l r -> FunctionType ctx (Vector l) (Eval ctx (Vector l))

-- | Construct a PureScript function type
(~>) :: FunctionType ctx al ar -> FunctionType ctx bl br -> FunctionType ctx (al -> br) (al -> br)
infixr 0 ~>

-- | This type class exists to facilitate the concise description of
--   PureScript type schemes using the <a>foreignImport</a> function. It is
--   best understood via its examples:
--   
--   <pre>
--   foreignImport (Ident "identity") a -&gt; a ~&gt; a
--     :: (Value ctx -&gt; Eval ctx (Value ctx)) 
--     -&gt; FFIBuilder ctx ()
--   
--   foreignImport (Ident "flip") a b c -&gt; (a ~&gt; b ~&gt; c) ~&gt; b ~&gt; a ~&gt; c
--     :: ((Value ctx -&gt; Value ctx -&gt; Eval ctx (Value ctx))
--     -&gt;   Value ctx -&gt; Value ctx -&gt; Eval ctx (Value ctx))
--     -&gt; FFIBuilder ctx ()
--   </pre>
--   
--   These Haskell functions applications describe the PureScript type
--   schemes for the <tt>identity</tt> and <tt>flip</tt> functions
--   respectively.
--   
--   Notice that the result type of these applications indicates the
--   corresponding Haskell type which must be implemented in order to
--   satisfy the contract of the FFI. Note, these types have been are
--   inferred, which highlights why this type class is worth its seeming
--   complexity: the goal is to allow the user to express the PureScript
--   type, and have the compiler compute the Haskell type for us. This is
--   about as simple as things can get - we cannot simply specify the
--   Haskell implementation and infer the PureScript type, because there is
--   not a single best PureScript type for every given Haskell type.
class ForAll ctx r a | a -> ctx r
instance Control.Monad.Writer.Class.MonadWriter (Dovetail.FFI.Builder.ForeignImports ctx) (Dovetail.FFI.Builder.FFIBuilder ctx)
instance GHC.Base.Monad (Dovetail.FFI.Builder.FFIBuilder ctx)
instance GHC.Base.Applicative (Dovetail.FFI.Builder.FFIBuilder ctx)
instance GHC.Base.Functor (Dovetail.FFI.Builder.FFIBuilder ctx)
instance GHC.Base.Semigroup (Dovetail.FFI.Builder.ForeignImports ctx)
instance GHC.Base.Monoid (Dovetail.FFI.Builder.ForeignImports ctx)
instance Dovetail.FFI.Builder.ForAll ctx a (Dovetail.FFI.Builder.FunctionType ctx a r_)
instance (Dovetail.FFI.Builder.ForAll ctx r o, a GHC.Types.~ Dovetail.FFI.Builder.FunctionType ctx (Dovetail.Types.Value ctx) (Dovetail.Types.Eval ctx (Dovetail.Types.Value ctx))) => Dovetail.FFI.Builder.ForAll ctx r (a -> o)


-- | A tiny standard library.
module Dovetail.Prelude
stdlib :: [FFI ctx]
prelude :: FFI ctx
preludeArray :: FFI ctx
preludeString :: FFI ctx
preludeChar :: FFI ctx
preludeNumber :: FFI ctx
preludeInt :: FFI ctx
preludeBoolean :: FFI ctx
preludeDebug :: FFI ctx
preludePartial :: forall ctx. FFI ctx
eqOps :: (ToValue ctx a, ToValueRHS ctx (Eval ctx a), Eq a) => FunctionType ctx a (Eval ctx a) -> FFIBuilder ctx ()
numOps :: (ToValue ctx a, ToValueRHS ctx (Eval ctx a), Num a) => FunctionType ctx a (Eval ctx a) -> FFIBuilder ctx ()
ordOps :: (ToValue ctx a, ToValueRHS ctx (Eval ctx a), Ord a) => FunctionType ctx a (Eval ctx a) -> FFIBuilder ctx ()

module Dovetail

-- | A monad transformer for high-level tasks involving PureScript code,
--   including separate compilation. Its job is to keep track of available
--   modules, any foreign imports from Haskell code, and run PureScript
--   code.
--   
--   Note: do not confuse this monad transformer with <tt>EvalT</tt>, which
--   is only responsible for powering evaluation of PureScript expressions.
--   
--   The transformed monad is used to track any benign side effects that
--   might be exposed via the foreign function interface to PureScript
--   code, in the same sense as <tt>EvalT</tt>.
data Interpret ctx a

-- | Run a computation in the <a>Interpret</a> monad, possibly returning an
--   error. Note: errors can occur during module building or evaluation
--   (i.e. module loading).
--   
--   The <a>runInterpret</a> function is a simpler alternative in the case
--   where benign side-effects are not needed.
--   
--   For example:
--   
--   <pre>
--   runInterpret <tt>Module () do
--     -- Load the prelude
--     <a>ffi</a> <tt>prelude</tt>
--     -- Build a module from source
--     <a>build</a> "module Main where main = \"example\"" --
--   
--   runInterpret </tt>(Eval Text) () do
--     <a>ffi</a> <tt>prelude</tt>
--     _ &lt;- <a>build</a> "module Main where main = \"example\""
--     -- Evaluate the main function
--     <a>evalMain</a> (<a>ModuleName</a> "Main")
--   </pre>
runInterpret :: ctx -> Interpret ctx a -> IO (Either (InterpretError ctx) a)

-- | A convenience function for running <tt>EvalT</tt> computations in
--   <a>Interpret</a>, reporting errors via <a>InterpretError</a>.
liftEval :: Eval ctx a -> Interpret ctx a

-- | Like <a>runInterpret</a>, but starts an interactive debugging session
--   in the event of a debugging error.
runInterpretWithDebugger :: ctx -> Interpret ctx a -> IO ()

-- | The type of errors that can occur in the <a>Interpret</a> monad.
data InterpretError ctx

-- | Evaluation errors can occur during the initial evaluation of the
--   module when it is loaded into the environment.
ErrorDuringEvaluation :: EvaluationError ctx -> InterpretError ctx

-- | Build errors can occur if we are building modules from source or
--   corefn.
ErrorDuringBuild :: BuildError -> InterpretError ctx
renderInterpretError :: RenderValueOptions -> InterpretError ctx -> String

-- | Make an <a>FFI</a> module available for use to subsequent operations.
--   
--   For example, to make the <a>prelude</a> available:
--   
--   <pre>
--   ffi <a>prelude</a>
--   </pre>
ffi :: FFI ctx -> Interpret ctx ()
loadEnv :: Env ctx -> Interpret ctx ()

-- | Build a PureScript module from source, and make its exported functions
--   available during subsequent evaluations.
build :: Text -> Interpret ctx (Module Ann)

-- | Build a PureScript module from corefn, and make its exported functions
--   available during subsequent evaluations.
--   
--   The corefn module may be preprepared, for example by compiling from
--   source text using the functions in the <a>Dovetail.Build</a> module.
buildCoreFn :: ExternsFile -> Module Ann -> Interpret ctx (Module Ann)
data BuildError
UnableToParse :: NonEmpty ParserError -> BuildError
UnableToCompile :: MultipleErrors -> BuildError
InternalError :: BuildError
renderBuildError :: BuildError -> String

-- | Evaluate a PureScript expression from source
eval :: ToValueRHS ctx a => Maybe ModuleName -> Text -> Interpret ctx (a, SourceType)

-- | Evaluate a PureScript corefn expression and return the result. Note:
--   The expression is not type-checked by the PureScript typechecker. See
--   the documentation for <a>ToValueRHS</a> for valid result types.
evalCoreFn :: ToValueRHS ctx a => Expr Ann -> Interpret ctx a

-- | Evaluate <tt>main</tt> in the specified module and return the result.
evalMain :: ToValueRHS ctx a => ModuleName -> Interpret ctx a

-- | The monad used by the interpreter, which supports error reporting for
--   errors which can occur during evaluation.
--   
--   The transformed monad is used to track any benign side effects that
--   might be exposed via the foreign function interface to PureScript
--   code.
newtype Eval ctx a
Eval :: ReaderT (EvaluationContext ctx) (ExceptT (EvaluationError ctx) IO) a -> Eval ctx a
[unEval] :: Eval ctx a -> ReaderT (EvaluationContext ctx) (ExceptT (EvaluationError ctx) IO) a

-- | An environment, i.e. a mapping from names to evaluated values.
--   
--   An environment for a single built-in function can be constructed using
--   the <tt>builtIn</tt> function, and environments can be combined easily
--   using the <a>Monoid</a> instance for <a>Map</a>.
data Env ctx
runEval :: ctx -> Eval ctx a -> IO (Either (EvaluationError ctx) a)

-- | <a>ToValue</a> should support functions with types such as
--   
--   <pre>
--   a -&gt; Eval ctx b
--   a -&gt; b -&gt; Eval ctx c
--   a -&gt; b -&gt; c -&gt; Eval ctx d
--   (a -&gt; Eval ctx b) -&gt; Eval ctx c
--   (a -&gt; b -&gt; Eval ctx c) -&gt; Eval ctx d
--   </pre>
--   
--   Note that every type in a return position is wrapped in the
--   <tt>EvalT</tt> monad transformer. This is because evaluation in
--   general may result in errors. However, a naive translation would
--   result in too many applications of <tt>EvalT</tt>.
--   
--   Specifically, we do not want to require types such as these, in which
--   <tt>EvalT</tt> appears on the right hand side of every function arrow:
--   
--   <pre>
--   a -&gt; Eval ctx b (b -&gt; Eval ctx c)
--   a -&gt; Eval ctx b (b -&gt; Eval ctx (c -&gt; Eval ctx d))
--   </pre>
--   
--   For this reason, the <a>ToValue</a> instance for functions delegates
--   to this type class for the type on the right hand side of the
--   function. It skips the application of <a>Eval</a> for nested function
--   types.
class ToValueRHS ctx a
toValueRHS :: ToValueRHS ctx a => a -> Eval ctx (Value ctx)
fromValueRHS :: ToValueRHS ctx a => Eval ctx (Value ctx) -> a

-- | Values which can be communicated across the FFI boundary from Haskell
--   to PureScript.
--   
--   Instances should identify and document any valid representations as a
--   subset of the semantic domain <a>Value</a>. Such a subset can be
--   identified by an injective function <a>toValue</a>, and a partial
--   inverse, <a>fromValue</a>, defined on the image of <a>toValue</a>.
--   
--   Laws:
--   
--   <pre>
--   fromValue . toValue = pure
--   </pre>
class ToValue ctx a

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: ToValue ctx a => a -> Value ctx

-- | The default implementation uses generic deriving to identify a Haskell
--   record type with a single data constructor with a PureScript record
--   with the same field names.
toValue :: (ToValue ctx a, Generic a, ToObject ctx (Rep a)) => a -> Value ctx
fromValue :: ToValue ctx a => Value ctx -> Eval ctx a
fromValue :: (ToValue ctx a, Generic a, ToObject ctx (Rep a)) => Value ctx -> Eval ctx a

-- | Start an interactive debugger (REPL) session.
repl :: Maybe ModuleName -> Interpret ctx ()
type Ann = (SourceSpan, [Comment], Maybe SourceType, Maybe Meta)
data Expr a
data Module a
instance Control.Monad.IO.Class.MonadIO (Dovetail.Interpret ctx)
instance Control.Monad.Reader.Class.MonadReader ctx (Dovetail.Interpret ctx)
instance Control.Monad.Error.Class.MonadError (Dovetail.InterpretError ctx) (Dovetail.Interpret ctx)
instance GHC.Base.Monad (Dovetail.Interpret ctx)
instance GHC.Base.Applicative (Dovetail.Interpret ctx)
instance GHC.Base.Functor (Dovetail.Interpret ctx)
