-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/paf31/runpurs-hs#readme</a>
@package runpurs-hs
@version 0.1.0.0

module Language.PureScript.Interpreter
type Env m = Map (Qualified Ident) (Value m)
data Value m
Object :: HashMap Text (Value m) -> Value m
Array :: Vector (Value m) -> Value m
String :: Text -> Value m
Number :: Scientific -> Value m
Bool :: Bool -> Value m
Null :: Value m
Closure :: (Value m -> EvalT m (Value m)) -> Value m
Constructor :: Constructor m -> Value m
data Constructor m
MkConstructor :: Qualified (ProperName 'ConstructorName) -> [Value m] -> [Ident] -> Constructor m
[ctorName] :: Constructor m -> Qualified (ProperName 'ConstructorName)
[ctorApplied] :: Constructor m -> [Value m]
[ctorUnapplied] :: Constructor m -> [Ident]
data EvaluationError
UnknownIdent :: Qualified Ident -> EvaluationError
TypeMismatch :: Text -> EvaluationError
FieldNotFound :: Text -> EvaluationError
InexhaustivePatternMatch :: EvaluationError

-- | TODO: remove this
NotSupported :: Text -> EvaluationError
InvalidNumberOfArguments :: Int -> Int -> EvaluationError
UnsaturatedConstructorApplication :: EvaluationError
InvalidFieldName :: PSString -> EvaluationError
OtherError :: Text -> EvaluationError
renderEvaluationError :: EvaluationError -> String
newtype EvalT m a
EvalT :: ExceptT EvaluationError m a -> EvalT m a
[runEvalT] :: EvalT m a -> ExceptT EvaluationError m a
type Eval = EvalT Identity
runEval :: Eval a -> Either EvaluationError a
eval :: forall m. Monad m => ModuleName -> Env m -> Expr () -> EvalT m (Value m)
apply :: Monad m => Value m -> Value m -> EvalT m (Value m)
interpret :: FromValue m a => Env m -> Module ann -> EvalT m a
class Monad m => ToValue m a
toValue :: ToValue m a => a -> Value m
toValue :: (ToValue m a, Generic a, GToObject m (Rep a)) => a -> Value m
class Monad m => FromValue m a
fromValue :: FromValue m a => Value m -> EvalT m a
fromValue :: (FromValue m a, Generic a, GFromObject m (Rep a)) => Value m -> EvalT m a
builtIn :: ToValue m a => Text -> a -> Env m
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Language.PureScript.Interpreter.EvaluationError (Language.PureScript.Interpreter.EvalT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Language.PureScript.Interpreter.EvalT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Language.PureScript.Interpreter.EvalT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Language.PureScript.Interpreter.EvalT m)
instance (GHC.Base.Monad m, Language.PureScript.Interpreter.FromValue m a, Language.PureScript.Interpreter.ToValueRHS m b) => Language.PureScript.Interpreter.ToValueRHS m (a -> b)
instance (GHC.Base.Monad m, Language.PureScript.Interpreter.FromValue m a, Language.PureScript.Interpreter.ToValueRHS m b) => Language.PureScript.Interpreter.ToValue m (a -> b)
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m (Language.PureScript.Interpreter.Value m)
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m Data.Text.Internal.Text
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m GHC.Integer.Type.Integer
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m Data.Scientific.Scientific
instance GHC.Base.Monad m => Language.PureScript.Interpreter.FromValue m GHC.Types.Bool
instance Language.PureScript.Interpreter.FromValue m a => Language.PureScript.Interpreter.FromValue m (GHC.Maybe.Maybe a)
instance Language.PureScript.Interpreter.FromValue m a => Language.PureScript.Interpreter.FromValue m (Data.Vector.Vector a)
instance (Language.PureScript.Interpreter.FromValue m a, n GHC.Types.~ m) => Language.PureScript.Interpreter.FromValueRHS m (Language.PureScript.Interpreter.EvalT n a)
instance (GHC.Base.Monad m, Language.PureScript.Interpreter.FromValueRHS m b, Language.PureScript.Interpreter.ToValue m a) => Language.PureScript.Interpreter.FromValue m (a -> b)
instance (GHC.TypeLits.KnownSymbol field, Language.PureScript.Interpreter.FromValue m a) => Language.PureScript.Interpreter.GFromObject m (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) u s l) (GHC.Generics.K1 r a))
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). (GHC.Base.Functor m, Language.PureScript.Interpreter.GFromObject m f) => Language.PureScript.Interpreter.GFromObject m (GHC.Generics.M1 GHC.Generics.D t f)
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). (GHC.Base.Functor m, Language.PureScript.Interpreter.GFromObject m f) => Language.PureScript.Interpreter.GFromObject m (GHC.Generics.M1 GHC.Generics.C t f)
instance forall k (m :: * -> *) (f :: k -> *) (g :: k -> *). (GHC.Base.Monad m, Language.PureScript.Interpreter.GFromObject m f, Language.PureScript.Interpreter.GFromObject m g) => Language.PureScript.Interpreter.GFromObject m (f GHC.Generics.:*: g)
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m (Language.PureScript.Interpreter.Value m)
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m GHC.Integer.Type.Integer
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m Data.Scientific.Scientific
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m Data.Text.Internal.Text
instance GHC.Base.Monad m => Language.PureScript.Interpreter.ToValue m GHC.Types.Bool
instance (Language.PureScript.Interpreter.ToValue m a, n GHC.Types.~ m) => Language.PureScript.Interpreter.ToValueRHS m (Language.PureScript.Interpreter.EvalT n a)
instance Language.PureScript.Interpreter.ToValue m a => Language.PureScript.Interpreter.ToValue m (GHC.Maybe.Maybe a)
instance Language.PureScript.Interpreter.ToValue m a => Language.PureScript.Interpreter.ToValue m (Data.Vector.Vector a)
instance (GHC.Base.Monad m, Language.PureScript.Interpreter.ToValue m a, Language.PureScript.Interpreter.FromValueRHS m b) => Language.PureScript.Interpreter.FromValueRHS m (a -> b)
instance (GHC.TypeLits.KnownSymbol field, Language.PureScript.Interpreter.ToValue m a) => Language.PureScript.Interpreter.GToObject m (GHC.Generics.M1 GHC.Generics.S ('GHC.Generics.MetaSel ('GHC.Maybe.Just field) u s l) (GHC.Generics.K1 r a))
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). Language.PureScript.Interpreter.GToObject m f => Language.PureScript.Interpreter.GToObject m (GHC.Generics.M1 GHC.Generics.D t f)
instance forall k (m :: * -> *) (f :: k -> *) (t :: GHC.Generics.Meta). Language.PureScript.Interpreter.GToObject m f => Language.PureScript.Interpreter.GToObject m (GHC.Generics.M1 GHC.Generics.C t f)
instance forall k (m :: * -> *) (f :: k -> *) (g :: k -> *). (Language.PureScript.Interpreter.GToObject m f, Language.PureScript.Interpreter.GToObject m g) => Language.PureScript.Interpreter.GToObject m (f GHC.Generics.:*: g)

module Language.PureScript.Interpreter.JSON
newtype JSON a
JSON :: a -> JSON a
[getJSON] :: JSON a -> a
fromJSON :: Value -> Value m
toJSON :: Value m -> Maybe Value
instance (GHC.Base.Monad m, Data.Aeson.Types.FromJSON.FromJSON a) => Language.PureScript.Interpreter.FromValue m (Language.PureScript.Interpreter.JSON.JSON a)
instance (GHC.Base.Monad m, Data.Aeson.Types.ToJSON.ToJSON a) => Language.PureScript.Interpreter.ToValue m (Language.PureScript.Interpreter.JSON.JSON a)

module Language.PureScript.Make.Simplified
data BuildError
UnableToParse :: NonEmpty ParserError -> BuildError
UnableToCompile :: MultipleErrors -> BuildError
renderBuildError :: BuildError -> String
buildSingleModule :: FilePath -> Text -> IO (Either BuildError (Module Ann))
buildCoreFnOnly :: Env -> [ExternsFile] -> Module -> IO (Either MultipleErrors (Module Ann, MultipleErrors))
